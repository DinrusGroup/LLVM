module ll.api.typs.Composite.StructType;

import ll.api.typs.Composite.CompositeType;
import ll.api.typs.IAggregateType;
import ll.api.typs.VoidType;
import ll.api.typs.LabelType;
import ll.api.typs.MetadataType;
import ll.api.typs.FunctionType;
import ll.api.typs.TokenType;
import ll.api.Type;
import ll.api.Context;
import ll.c.Types;
import ll.c.Core;

import ll.common;


    public class ТипСтрукт : ТипКомпозит, ИТипАгрегат
    {

/////PRIVATE/////////////////////////////////

		private ткст имя;
		private Контекст контекст;

		//Структура выглядит как массив типов
		private Тип[] типыЭлтов;
		private ЛЛТип[] базТипыЭлтов;

		//Она может быть упакована или не упакована
		private бул упаковать_ли;

    	/**
    	* Базовый тип = LLVMOpaqueTypeRef = ЛЛТип
    	*/
    	private ЛЛТип экзэмпл;

////////////////////////////////////////////
/////PUBLIC//////////////////////////////////////////
		/**
    	* Базовый конструктор
    	*/
        this(ЛЛТип экзэмпл)
		{            
			this.экзэмпл = экзэмпл;
			super(экзэмпл);

        }
        /**
        * Функция для передачи базового типа
        */
        public override ЛЛТип раскрой()
		{
            return this.экзэмпл;
		}

		/**
		* 1-й конструктор.
		* В заданном контексте создаёт пустую неупакованную структуру с именем.
		* Элементы устанавливаются потом,
		* с помощью функции проц устТело(Типы элементов, бул упаковать_ли);
		*/
        public this(Контекст контекст, ткст имя)
		{
			this.имя = имя;
			this.контекст = контекст;
			//Использует базовый констуктор
			this(ЛЛСтруктСоздайСИменем(контекст.раскрой(), вТкст0(имя)));
		}

		/**
		* 2-й конструктор.		
		* Итог - безымянная неупакованная структура в заданном контексте.
		* Элементы устанавливаются потом,
		* с помощью функции проц устТело(Типы элементов, бул упаковать_ли);
		*/
		 public this(Контекст контекст)
		{
			this.имя = "Без_Имени";
			this.контекст = контекст;
			//Использует базовый констуктор
			this(ЛЛТипСтруктВКонтексте(контекст.раскрой(), null, бцел.init, false));
		}

		 /**
		 * 3-й конструктор.
		 * Позволяет создать структуру с именем, типами элементов, упаковкой и контекстом.
		 * Наиболее полная версия конструктора.
		 */
		 public this(Контекст контекст, Тип[] типыЭлтов, ткст имя, бул упакован)
		 {
			this.имя = имя;
			this.контекст = контекст;

			//Использует 1-й конструктор.
            this(контекст, имя);
			//Устанавливает тело структуры дополнительной функцией
            this.устТело(типыЭлтов, упакован);
		 }   

		public проц устТело(Тип[] типыЭлтов, бул упакован = нет)
		{ 
			//Фиксируем установку тела в приватной части класса:
			this.упаковать_ли = упакован; // по умолчанию - нет

			//В этой функции вызывает недоразумение одно:
			//надо передавать массив целиком, либо же по одному?
			//Поэтому пытаюсь сначала создать цельный указатель на массив....

			//Массив базовых типов, который надо передать LLVM-библиотеке:
			ЛЛТип[] лТипы;

			//Счётчик номера указанного элемента в заданном массиве:
			бцел номерЭлта = 0;

			//Извлекаем базовые типы с проверкой пригодности:
			foreach(Тип элт; типыЭлтов)
			{
				//Увеличим нумерацию элементов:
				this.типыЭлтов ~= элт;
				номерЭлта++;
				//Проверим пригодность и раскроем Тип:
				//if(валиденТипЭлта_ли(элт))	
				//{
					лТипы ~= элт.раскрой();
					this.базТипыЭлтов ~= элт.раскрой();
			//	}
				//Сообщим о несоответствиях:
				//else инфо(фм("Задан неуместный тип <{}> элемента <{}> cтруктуры", элт.вТкст(),номерЭлта));
				assert(this.базТипыЭлтов == лТипы);
				this.типыЭлтов = типыЭлтов;
			}

			//Попробуем теперь проверить, получили ли мы установку структуры
			//в точности по числу указанных нами Типов:
			assert(номерЭлта == this.длина);

			//Отправляем базовые типы в LLVM-библиотеку.
			ЛЛСтруктУстТело(this.раскрой(),cast(ЛЛТип*) &лТипы, лТипы.length, упакован);
			
			assert(this.типыЭлтов == this.дайТипыЭлтов());

		}
/+
		//Проверяет, подходит ли такой тип элемента.
        public static бул валиденТипЭлта_ли(Тип тип)
        {
            return (typeof(тип) !is ll.api.typs.VoidType.ТипПроц) && (typeof(тип)  !is ТипЯрлык) &&
                   (typeof(тип)  !is ТипМетаданные) && (typeof(тип)  !is ll.api.typs.FunctionType.ТипФункция) &&
                   (typeof(тип) !is ТипСема);
        }
+/
		/**
		* Выводит длину структуры.
		*/
        public бцел длина()
		{
			return ЛЛПосчитайТипыЭлементовСтрукт(this.раскрой());
		}

		/**
		* Выводит тип элемента по индексу в массиве структуры.
		*/
        public Тип дайТипЭлта(бцел индекс)
		{
			ЛЛТип[] приёмник;
			ЛЛДайТипыЭлементовСтрукт(this.раскрой(), cast(ЛЛТип*) &приёмник);
			return new Тип(приёмник[индекс]);
		}

		/**
		* Выводит массив типов элементов структуры.
		*/
        public Тип[] дайТипыЭлтов()
		{
			ЛЛТип[] приёмник;
			ЛЛДайТипыЭлементовСтрукт(this.раскрой(), cast(ЛЛТип*) &приёмник);

			Тип[] типы;
			foreach(т;приёмник)
			{
				типы ~= new Тип(т);
			}

			return типы;
		}

		/**
		* Выводит имя массива, полученное LLVM.
		*/
        public override ткст вТкст()
		{
			assert(this.имя == ll.common.вТкст(ЛЛДайИмяСтрукт(this.раскрой())));
			return this.имя;
		}

		/**
		* Проверяет, следует ли упаковать структуру.
		*/
        public бул упакован_ли()
        {
            return ЛЛУпакованнаяСтруктура_ли(this.раскрой());
        }

		/**
		* Переустанавливает структуру, изменяя параметр упаковки.
		*/
		public проц упаковать(бул данет)
		{
			this.устТело(this.типыЭлтов, данет);
		}

        public бул опак_ли()
		{
			return ЛЛОпакСтрукт_ли(this.раскрой());
		}
/+
        public бул литерал_ли()
		{
			// throw new NotImplementedException();
		}

        public бул раскладкаИдентична_ли(ТипСтрукт other)
		{ 
			//throw new NotImplementedException();
		}
+/
        public override бул валиденИндекс_ли(бцел индекс) 
		{
			return индекс < this.длина;
		}

        public override Тип дайТипПоИндексу(бцел индекс)
		{
			if(валиденИндекс_ли( индекс))
			   return this.типыЭлтов[индекс];
			else
				throw new АргВнеИскл("Индекс запределен!");
		}


    }

public class ТипГлобСтрукт: ТипСтрукт
{
	public this(Тип[] типыЭлтов, ткст имя, бул упакован)
	{
		super(ЛЛСтруктСоздайСИменем(ГлобКонтекст.раскрой(), вТкст0(имя)));
		this.устТело(типыЭлтов, упакован);            
	}
}
